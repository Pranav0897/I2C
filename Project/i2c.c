/*********
 * i2c.c *
 *********/

/* FreeRTOS includes */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

/* Project includes */
#include "FreeRTOSConfig.h"
#include "lpc2103.h"
#include "i2c.h"

#define i2cSTACK_SIZE	((unsigned portSHORT) configMINIMAL_STACK_SIZE)

/* Function prototypes */
void prvI2C_Transaction( xI2C_struct *pxI2C);

/* Declare global variables */
volatile unsigned portCHAR ucI2C_busy;
xQueueHandle pxI2C_RQ;
xSemaphoreHandle xI2CSemaphore = NULL;

/*****************
 * vStartI2CTask *
 *****************/
void vStartI2CTask( unsigned portBASE_TYPE uxPriority )
{
	xTaskCreate( vI2CTask, (const signed portCHAR*)"I2C", i2cSTACK_SIZE,( void * ) NULL, uxPriority,( xTaskHandle * ) NULL );
}

/************
 * I2C Task *
 ************
 * This task implements a deferred interrupt handler for I2C0
 * - see i2cISR.c
 */
void vI2CTask( void* pvParameters __attribute__ ((unused)))
{
	/* Declare local variables */
	static xI2C_struct *pxI2C;	/* Pointer to parameter structure
								 * for an I2C request
								 */

	static unsigned portCHAR ucI2C_status;	/* I2C controller status */
	static unsigned portCHAR ucI2C_saddr;	/* I2C slave address
											   - bits[7:1] = I2C address
											   - bit[0]	   = R/W bit
											 */
	static unsigned portCHAR ucI2C_lstate;	/* Last I2C transaction state */
	static unsigned portCHAR ucI2C_cstate;	/* Current I2C transaction state */
	static unsigned portCHAR ucI2C_wr_count;/* # of data bytes transmitted */
	static unsigned portCHAR ucI2C_rd_count;/* # of data bytes received */

	/* Pending transaction flag */
	static unsigned portCHAR ucI2C_pending = pdFALSE;

	/* Task initialization code goes here (runs once)
	 * - none currently
	 */

	/* Repetitive Task code goes here (runs forever) */
	for(;;){

		/* Check the I2C semaphore for a deferred I2C interrupt
		 * - proceed only if a the semaphore has been "given"
		 * - if semaphore has not been given, delay 1 "tick" and try again
		 */
		if (xSemaphoreTake(xI2CSemaphore, (portTickType) 1) == pdTRUE) {

			/* i2cISR.c determined that an I2C interrupt was asserted at the
			 * VIC. Verify that I2C0 controller is reporting an interrupt.
			 *
			 * - I2C0CONSET bit 3: Interrupt Status
			 * 						0 - No IRQ from I2C0
			 * 						1 - I2C0 IRQ asserted
			 */
			if(READ(I2C0CONSET) & 0x08) {

				/* I2C0 interrupt is asserted, get current I2C status */
				ucI2C_status = READ(I2C0STAT);

				/* Save "last" state.
				 *
				 * NOTE: if this is the start of a new I2C transaction then
				 *       the "last" state will be initialized to "I2C_START"
				 *       in case 0x8 of the switch statement below.
				 */
				ucI2C_lstate = ucI2C_cstate;

				/* An I2C transaction is executed in multiple steps. One
				 * interrupt is generated by the I2C0 controller for each
				 * step (i.e. each I2C0 state transition).
				 *
				 * The switch statement below executes state-specific code
				 * which determines the next I2C0 controller action.
				 *
				 * After the case-specific code has been executed the current I2C
				 * interrupt is cleared and VIC priority is reset (by a dummy write
				 * to VICADDR).
				 */
				switch(ucI2C_status) {


				/*************************
				 * CASE 0x00 - Bus ERROR *
				 *************************
				 * Bus Error is a condition detected by the I2C0
				 * controller hardware.
				 */
				case 0x00:
					/* Set current I2C transaction state */
					ucI2C_cstate = I2C_ERROR_STOP;

					/* The I2C transaction is terminated by asserting the STOP
					 * bit in the I2C0CONSET register (done at end of this
					 * interrupt handler).
					 */
					//WRITE(I2C0CONSET, 0x10);

					break; /* case 0x00 */


				/*********************************
				 * CASE 0x08 - START transmitted *
				 *********************************
				 * All I2C transactions begin with the the transmission of
				 * a START condition.
				 */
				case 0x08:
					/* Update I2C transaction "last state" variable.
					 *
					 * NOTE: in this case we KNOW that the "last state"
					 *       was actually START
					 */
					ucI2C_lstate = I2C_START;

					/* Initialize data counters */
					ucI2C_wr_count = 0;
					ucI2C_rd_count = 0;

					/* Clear the start bit */
					WRITE(I2C0CONCLR, 0x20);

					/* An I2C transaction can be started in one of two ways...
					 *
					 * 1) ucI2C_pending == pdFALSE
					 *
					 *    The request queue was empty and a new I2C transaction
					 *    request is queued and initiated by prvI2C_Transaction().
					 *
					 *    In this case, the I2C request is removed from the I2C
					 *    request queue by code following this comment.
					 *
					 * 2) ucI2C_pending == pdTRUE
					 *
					 *    A previous I2C transaction was completed by this I2C
					 *    interrupt handling code and at least one I2C
					 *    request was pending (queued) at that time.
					 *
					 *    The next request was removed from the queue and the
					 *    I2C transaction was initiated by code at the bottom
					 *    of this interrupt handling code.
					 */
					if (ucI2C_pending == pdFALSE) {

						/* prvI2C_Transaction() started the I2C transaction
						 *
						 * Get the request from the I2C transaction request
						 * queue. The "request" is the address of a pointer
						 * to a structure that contains the I2C transaction
						 * parameters.
						 */
						xQueueReceive(pxI2C_RQ, &(pxI2C), (portTickType) 0);

					} /* end if (ucI2C_pending == pdFALSE) */

					/* Compose the I2C address.
					 *
					 * - bits[7:1]	= 7-bit I2C slave address
					 * - bit[0]		= read/write bit
					 * 					0 = write
					 * 					1 = read
					 */
					ucI2C_saddr = pxI2C->addr << 1;

					/* ucI2C_saddr[0] = 0 as a result of the left shift
					 * which indicates an I2C write transaction by DEFAULT.
					 *
					 * Set ucI2C_saddr[0] = 1 in the following cases:
					 *
					 * - If we have a RECEIVE BYTE opcode to indicate an I2C
					 *   read transaction
					 *
					 * - If we have a QUICK opcode and bit[0] of
					 *   pxI2C->data[0] = 1
					 *
					 * NOTE: Composite I2C transactions that have a COMMAND
					 *       byte will indicate "read" in the subsequent
					 *       REPEARED-START phase of the transaction.
					 */
					ucI2C_cstate = I2C_WR_ADDR;

					if (pxI2C->opcode == I2C_ReceiveByte){
						ucI2C_saddr = ucI2C_saddr | 0x01;
						ucI2C_cstate = I2C_RD_ADDR;
					}

					if (pxI2C->opcode == I2C_Quick){
						ucI2C_saddr = ucI2C_saddr | (0x01 & pxI2C->data[0]);
						ucI2C_cstate = I2C_QUICK;
					}

					/* Load the slave address for transmission */
					WRITE(I2C0DAT, ucI2C_saddr);

					break; /* case 0x08 */


				/******************************************
				 * CASE 0x10 - REPEATED-START transmitted *
				 ******************************************
				 * A REPEATED-START is used in all composite I2C
				 * transactions (transactions that have a COMMAND byte).
				 *
				 * 	- READ BYTE
				 *  - READ WORD
				 *
				 * A REPEATED-START will also occur after
				 * loss-of-arbitration.
				 *
				 * This case can occur in both Master-Transmit and
				 * Master-Receive mode.
				 */
				case 0x10:

					/* Determine the reason for the REPEATED-START */
					if (ucI2C_lstate == I2C_LOST_ARB) {

						/* When arbitration is lost the I2C transaction
						 * must be replayed beginning with the I2C slave
						 * address.
						 *
						 * Reset the current state.
						 */
						if (pxI2C->opcode == I2C_ReceiveByte){

							ucI2C_cstate = I2C_RD_ADDR;
						}
						else{
							ucI2C_cstate = I2C_WR_ADDR;
						}

					}
					else {
						/* The REPEATED-START occurred as a normal part of a
						 * READ BYTE or READ WORD transaction (which include a
						 * COMMAND byte).
						 *
						 * The I2C slave "read" address will be transmitted
						 * next.
						 */
						ucI2C_cstate = I2C_RD_ADDR;

						/* Set slave address bit[0] to indicate a read */
						ucI2C_saddr = ucI2C_saddr | 0x01;
					} /* End if (ucI2C_lstate == I2C_LOST_ARB) */

					/* Clear the START bit */
					WRITE(I2C0CONCLR, 0x20);

					/* Write the slave address to the the I2C0 controller */
					WRITE(I2C0DAT, ucI2C_saddr);

					break; /* case 0x10 */


				/********************************************************
				 * CASE 0x18 -  Slave ADDR+WR transmitted, ACK received *
				 ********************************************************
				 * Previous I2C transaction state was 0x08 or 0x10.
				 *
				 * This case can only occur in Master-Transmit mode.
				 *
				 */
				case 0x18:

					switch( pxI2C->opcode){

					case 0:	/* QUICK COMMAND */
						/* Transaction complete
						 * - a single bit of write data was included in bit[0]
						 *   of the slave address
						 *
						 * Set current I2C transaction state.
						 */
						ucI2C_cstate = I2C_STOP;

						/* The I2C transaction is terminated by asserting the
						 * STOP bit in I2C0CONSET (done at end of this
						 * interrupt handler).
						 */

						break; /* case 0 QUICK COMMAND */

					case 1: /* SEND BYTE */
						/* Set current I2C transaction state */
						ucI2C_cstate = I2C_WR_DATA;

						/* Transmit data byte 0 */
						WRITE(I2C0DAT, pxI2C->data[ucI2C_wr_count]);
						ucI2C_wr_count++;

						break; /* case 1 SEND BYTE */

					case 3: /* WRITE BYTE */
					case 4: /* READ BYTE */
					case 5: /* WRITE WORD */
					case 6: /* READ WORD */

						/* All of these transactions include a I2C
						 * command byte.
						 *
						 * Set current I2C transaction state.
						 */
						ucI2C_cstate = I2C_COMMAND;

						/* Transmit command byte */
						WRITE(I2C0DAT, pxI2C->comm);

						break; /* case 3 - 9 */

					default:

						/* Could only get here if an error occurs.
						 *
						 * Set current I2C transaction state.
						 */
						ucI2C_cstate = I2C_ERROR_STOP;

						/* The I2C transaction is terminated by asserting the
						 * STOP bit in I2C0CONSET (done at end of this
						 * interrupt handler
						 */

					} /* End switch( pxI2C->opcode) */

					break; /* case 0x18 */


				/********************************************************
				 * CASE 0x20 - Slave ADDR+WR transmitted, NACK received *
				 ********************************************************S
				 * Previous state was 0x08 or 0x10.
				 *
				 * This can only occur in Master-Transmit mode.
				 */
				case 0x20:
					/* Slave NACK'd the transaction
					 *
					 * - this is an ERROR condition
					 *
					 * Set current I2C transaction state
					 */
					ucI2C_cstate = I2C_ERROR_STOP;

					/* The I2C transaction is terminated by asserting the STOP
					 * bit in I2C0CONSET (done at the end of this interrupt
					 * handler).
					 */

					break; /* case 0x20 */


				/**********************************************
				 * CASE 0x28 - Data transmitted, ACK received *
				 **********************************************
				 * Previous state was 0x18.
				 *
				 * This can only occur in Master-Transmit mode.
				 */
				case 0x28:

					switch( pxI2C->opcode){

					case 1: /* SEND BYTE */
						/* Set current I2C transaction state */
						ucI2C_cstate = I2C_STOP;

						/* Transaction done.
						 *
						 * The I2C transaction is terminated by asserting the
						 * STOP bit in I2C0CONSET (done at end of this
						 * interrupt handler).
						 */

						break; /* case 1 SEND BYTE */

					case 3: /* WRITE BYTE */
					case 5: /* WRITE WORD */
						if( ((pxI2C->opcode == I2C_WriteByte) && (ucI2C_wr_count < 1)) ||
						    ((pxI2C->opcode == I2C_WriteWord) && (ucI2C_wr_count < 2)) ){
							/* Set current I2C transaction state */
							ucI2C_cstate = I2C_WR_DATA;

							/* Transmit data byte */
							WRITE(I2C0DAT, pxI2C->data[ucI2C_wr_count]);
							ucI2C_wr_count++;
						}
						else{
							/* All data has been sent.
							 *
							 * Set current I2C transaction state.
							 */
							ucI2C_cstate = I2C_STOP;

							/* The I2C transaction is terminated by asserting
							 * the STOP bit in I2C0CONSET (done at the end of
							 * this interrupt handler).
							 */

						}
						break;	/* Case 3 WRITE BYTE */
								/* Case 5 WRITE WORD */

					case 4: /* READ BYTE */
					case 6: /* READ WORD */
						/* Set current I2C transaction state */
						ucI2C_cstate = I2C_RSTART;

						/* Transmit a REPEATED-START */
						WRITE(I2C0CONSET, 0x20);

						break; /* case 4 READ BYTE
								* case 6 READ WORD
								*/

					default:
						/* Can only get here if an error occurs.
						 *
						 * Set current I2C transaction state.
						 */
						ucI2C_cstate = I2C_ERROR_STOP;

						/* The I2C transaction is terminated by asserting the
						 * STOP bit in I2C0CONSET (done at end of this
						 * interrupt handler).
						 */

					} /* End switch( pxI2C->opcode) */

					break; /* case 0x28 */


				/***********************************************
				 * CASE 0x30 - Data transmitted, NACK received *
				 ***********************************************
				 * Previous state was 0x18.
				 *
				 * This can only occur in Master-Transmit mode.
				 */
				case 0x30:
					/* Slave NACK'd data. This is an error case.
					 *
					 * Set current I2C transaction state
					 */
					ucI2C_cstate = I2C_ERROR_STOP;

					/* The I2C transaction is terminated by asserting
					 * the STOP bit in I2C0CONSET (done at the end of
					 * this interrupt handler).
					 */

					break; /* case 0x30 */


				/********************************
				 * CASE 0x38 - Arbitration lost *
				 ********************************/
				case 0x38:
					/* Arbitration was lost during an I2C transaction.
					 *
					 * This can occur in Master-Transmit or
					 * Master-Receive mode.
					 *
					 * NOTE: This case cannot occur if the LPC2103 is
					 *       the ONLY master on an I2C bus.
					 *
					 * Set current I2C transaction state.
					 */
					ucI2C_cstate = I2C_LOST_ARB;

					/* Restart (retry) the I2C transaction */
					WRITE(I2C0CONSET, 0x20);

					break; /* case 0x38 */


				/*******************************************************
				 * CASE 0x40 - Slave ADDR+RD transmitted, ACK received *
				 * *****************************************************
				 * Previous state was 0x08 or 0x10
				 */
				case 0x40:

					switch(pxI2C->opcode){

					case 0:	/* QUICK COMMAND */
						/* Transaction complete
						 * - a single bit of write data was included in bit[0]
						 *   of the slave address
						 *
						 * Set current I2C transaction state.
						 */
						ucI2C_cstate = I2C_STOP;

						/* The I2C transaction is terminated by asserting the
						 * STOP bit in I2C0CONSET (done at end of this
						 * interrupt handler).
						 */

						break; /* case 0 QUICK COMMAND */

					case 2:	/* RECEIVE BYTE */
					case 4: /* READ BYTE */
					case 6: /* READ WORD */
						/* Transition to Master-Receive mode
						 * - Slave transmits data
						 * - Master receives data and responds with ACK/NACK
						 *
						 * Set current I2C transaction state.
						 */
						ucI2C_cstate = I2C_RD_ADDR_ACK;

						if( (pxI2C->opcode == I2C_ReceiveByte) ||
							(pxI2C->opcode == I2C_ReadByte) ) {

							/* RECEIVE BYTE or READ BYTE
							 *
							 * Disable ACK
							 * - the first data byte read will also be the
							 *   last data byte read
							 * - disable ACK for the last data byte
							 */
							WRITE(I2C0CONCLR, 0x04);
						}
						else { /* READ WORD */
							/* Enable ACK
							 * - this is the first data byte read
							 * - enable ACK for this data byte
							 */
							WRITE(I2C0CONSET, 0x04);
						}

						break; /* case 2 RECEIVE BYTE
								* case 4 READ BYTE
								* case 6 READ WORD
								*/

					default:
						/* Can only get here if an error occurs.
						 *
						 * Set current I2C transaction state.
						 */
						ucI2C_cstate = I2C_ERROR_STOP;

						/* The I2C transaction is terminated by asserting the
						 * STOP bit in I2C0CONSET (done at end of this
						 * interrupt handler).
						 */

					} /* End switch(pxI2C->opcode) */

					break; /* case 0x40 */


				/********************************************************
				 * CASE 0x48 - Slave ADDR+RD transmitted, NACK received *
				 ********************************************************
				 * Occurs in Master-Receive mode only.
				 *
				 * Previous state was 0x08 or 0x10
				 */
				case 0x48:
					/* Slave NACK'd address. This is an error case.
					 *
					 * Set current I2C transaction state
					 */
					ucI2C_cstate = I2C_ERROR_STOP;

					/* The I2C transaction is terminated by asserting the STOP
					 * bit in I2C0CONSET (done at the end of this interrupt
					 * handler).
					 */

					break; /* case 0x48 */


				/***************************************************
				 * CASE 0x50 - Data byte received, ACK transmitted *
				 ***************************************************
				 * Occurs in Master-Receive mode only.
				 */
				case 0x50:
					switch(pxI2C->opcode){

						case 6: /* READ WORD */
							/* The first byte of read data has been received
							 * and ACK has been transmitted.
							 *
							 * Set current I2C transaction state.
							 */
							ucI2C_cstate = I2C_RD_DATA_NAK;

							/* Disable ACK
							 * - don't acknowledge the last read data byte
							 */
							WRITE(I2C0CONCLR, 0x04);

							/* Read the last data byte */
							pxI2C->data[ucI2C_rd_count] = READ(I2C0DAT);
							ucI2C_rd_count++;

							break; /* case 6 READ WORD
							        * case 7 PROCESS CALL
							        */

						default:
							/* Could only get here if an error occurs.
							 *
							 * Set current I2C transaction state.
							 */
							ucI2C_cstate = I2C_ERROR_STOP;

							/* The I2C transaction is terminated by asserting
							 * the STOP bit in I2C0CONSET (done at end of this
							 * interrupt handler).
							 */

					} /* switch(pxI2C->opcode) */

					break; /* case 0x50 */


				/****************************************************
				 * CASE 0x58 - Data byte received, NACK transmitted *
				 ****************************************************
				 * Occurs in Master-Receive mode only.
				 */
				case 0x58:
					/* RECEIVE BYTE, READ BYTE, or READ WORD
					 *
					 * Read the last data byte of the transaction. This will
					 * complete the I2C transaction.
					 *
					 * Set current I2C transaction state.
					 */
					ucI2C_cstate = I2C_STOP;

					/* Read the last data byte */
					pxI2C->data[ucI2C_rd_count] = READ(I2C0DAT);
					ucI2C_rd_count++;

					/* Transaction done.
					 *
					 * The I2C transaction is terminated by asserting the STOP
					 * bit in I2C0CONSET (done at the end of this interrupt
					 * handler).
					 */
					break;


				/************************
				 * CASE DEFAULT - ERROR *
				 ************************
				 * Can only get here if an error occurs.
				 */
				default:
					/* Set current I2C transaction state */
					ucI2C_cstate = I2C_ERROR_STOP;

					/* The I2C transaction is terminated by asserting the STOP
					 * bit in I2C0CONSET (done at the end of this interrupt
					 * handler.
					 */

				} /* End switch(ucI2C_status) */


				/* If the transaction is done or an error occurred then generate
				 * an I2C transaction "completion" to the requesting task.
				 */
				if( (ucI2C_cstate == I2C_STOP) ||
					(ucI2C_cstate == I2C_ERROR_STOP) ) {

					/* If I2C_STOP:
					 *
					 * - The STOP bit in I2C0CONSET must be set to terminate the
					 *   I2C transaction normally.
					 *
					 * If I2C_ERROR_STOP...
					 *
					 * - Writing the STOP bit in the pxI2CCONET aborts the current
					 *   I2C transaction and restores the I2C controller to an
					 *   operational state. This terminates, but does not recover
					 *   an I2C transaction that may have been in progress.
					 */
					WRITE(I2C0CONSET, 0x10);

					/* Return status, read length (count), and read data
					 * - pxI2C->rd_len and pxI2C->data[] already contain data
					 * - need to update pxI2C->status here
					 */
					pxI2C->status = ucI2C_cstate;


					/* Return the completion for the I2C transaction request */
					xQueueSendToBack(pxI2C->pxHandle, (void *) NULL, (portTickType) 0);


					/* Done with the prior I2C transaction. Check for a new
					 * (pending) transaction.
					 *
					 * An I2C transaction can be started in one of two ways:
					 *
					 * - The request queue was empty and a new I2C transaction
					 *   request is queued and started by prvI2C_Transaction().
					 *   In this case the new request is removed from the queue
					 *   at the top of this I2C interrupt handler.
					 *
					 *   - see "switch(ucI2C_status)" case 0x08
					 *
					 * - An I2C transaction was completed by this interrupt
					 *   handler and at least one I2C transactions was pending
					 *   (already queued). In this case the next I2C
					 *   transaction is started and the request is removed
					 *   from the queue by the code below...
					 */
					ucI2C_pending = (unsigned portCHAR) xQueueReceive(pxI2C_RQ,
							         &(pxI2C), (portTickType) 0);

					if (ucI2C_pending == pdTRUE) {

						/* A transaction is pending
						 * - the I2C request queue was NOT empty
						 *
						 * Start the new I2C transaction. This will cause
						 * subsequent I2C interrupts that will eventually
						 * complete the transaction.
						 *
						 * NOTE: ucI2C_busy will remain == pdTRUE
						 */
						WRITE(I2C0CONSET, 0x20);
					}
					else {
						/* No pending I2C transactions
						 * - the I2C request queue was empty
						 *
						 * Clear the ucI2C_busy flag.
						 */
						ucI2C_busy = pdFALSE;
					} /* end if (ucI2C_pending == pdTRUE) */

				} /* end if( (ucI2C_cstate == I2C_STOP) || (ucI2C_cstate == I2C_ERROR_STOP) ) */


				/* The I2C interrupt for any cases above has been serviced.
				 *
				 * Clear the I2C0 interrupt.
				 */
				WRITE(I2C0CONCLR, 0x08);
			}
			else {
				/* If execution gets HERE (this else clause) then the VIC
				 * detected an I2C0 controller asserted an interrupt but I2C0
				 * status indicates that there is no interrupt pending.
				 *
				 * Assume that this is a "spurious" VIC interrupt.
				 *
				 * There is no code to execute here.
				 */
			} /* if(READ(I2C0CONSET) & 0x08) */

			/* Un-mask VIC I2C0 interrupt.
			 *
			 * This will enable subsequent I2C0 interrupts.
			 */
			WRITE(VICIntEnClear, 0x00000200);

			/* Done servicing I2C0 interrupt */

			} /* End if (xSemaphoreTake(xI2CSemaphore, (portTickType) 1) == pdTRUE) */

		/* Execute a delay to yield to other tasks */
		vTaskDelay((portTickType) 1);

	} /* End for(;;;) */
}

/***************
 * vI2C_Init() *
 ***************
 * I2C initialization code called by main
 * - uxQueueLength specifies the number of entries in the request queue
 */
void vI2C_Init( unsigned portBASE_TYPE uxQueueLength )
{
	/* Declare enternal variables */
	extern void ( vI2C_ISR_Wrapper )(void);

	portENTER_CRITICAL();

	/* Configure the LPC-2103 pins used for I2C0
	 * - P0.3 = SDA0 (I2C0 data), PINSEL[7:6] = 01
	 * - P0.2 = SCL0 (I2C0 clock), PINSEL[5:4] = 01
	 */
	WRITE(PINSEL0, (READ(PINSEL0) | 0x50));

	/* Clear I2C0 register */
	WRITE(I2C0CONCLR, 0x7C);

	/* Configure the I2C0 clock for 100 KHz operation
	 * - 10 us period (5 us high, 5 us low)
	 * - CPU clock (Cclk) = 58.9824 MHz
	 * - Pclk = Cclk
	 * 		5 us ~= 295 / 58.9824 MHz
	 */
	WRITE(I2C0SCLH, 295);
	WRITE(I2C0SCLL, 295);

	/* Set I2C0 master enable */
	WRITE(I2C0CONSET, 0x40);

	/* Clear I2C0 interrupt (just in case) */
	WRITE(I2C0CONCLR, 0x8);

	/* Configure the Vectored Interrupt Controller for I2C1 interrupt
	 * - VIC channel 9 = I2C0 interrupt
	 * - Use VICVectAddr1
	 * - Use VICVectCntl1
	 * 		Set VIC IRQ "slot" enable, bit[5] = 1
	 * 		SET VIC IRQ channel = 9 (I2C0), bits[4:0] = 01001
	 *
	 * 		bits[5:0] = 0x29
	 */
	WRITE(VICVectAddr1, (unsigned portBASE_TYPE) vI2C_ISR_Wrapper);
	WRITE(VICVectCntl1, 0x29);

	/* Enable I2C0 interrupt (VIC channel 9)
	 * - Set VICIntEnable[9] (0x00000200)
	 */
	WRITE(VICIntEnable, (READ (VICIntEnable) | 0x00000200) );

	/* Initialize I2C busy flag = idle */
	ucI2C_busy = pdFALSE;

	portEXIT_CRITICAL();

	/* Create I2C request queue
	 * - one entry per task that issues I2C transaction requests
	 */
	pxI2C_RQ = xQueueCreate( uxQueueLength, sizeof( xI2C_struct * ) );

	/* Create I2C semaphore
	 * - i2cISR.c "gives" the semaphore to i2c.c which "handles" the
	 *   interrupt (deferred interrupt handler). The semaphore is "taken" by
	 *   i2c.c which then services the interrupt condition.
	 */
	vSemaphoreCreateBinary( xI2CSemaphore );


} /* End of vI2C_Init */

/*****************
 * ucI2C_Quick() *
 ****************/
unsigned portCHAR ucI2C_Quick (xI2C_struct *pxI2C,
							   unsigned portCHAR addr,
							   unsigned portCHAR data)
{

	/* Initialize parameters for request */
	pxI2C->opcode	= I2C_Quick;		/* I2C transaction code */
	pxI2C->addr		= addr;		        /* Address (before left shift) */
	pxI2C->data[0]	= data;				/* Write data bit (low bit only) */

	/* Queue I2C transaction request and wait for completion */
	prvI2C_Transaction(pxI2C);

	/* I2C transaction complete, return status */
	return pxI2C->status;

} /*end ucI2C_Quick */

/********************
 * ucI2C_SendByte() *
 *******************/
unsigned portCHAR ucI2C_SendByte (xI2C_struct *pxI2C,
								  unsigned portCHAR addr,
								  unsigned portCHAR data)
{

	/* Initialize parameters for request */
	pxI2C->opcode	= I2C_SendByte;		/* I2C transaction code */
	pxI2C->addr		= addr;		        /* Address (before left shift) */
	pxI2C->data[0]	= data;				/* Write data byte */

	/* Queue I2C transaction request and wait for completion */
	prvI2C_Transaction(pxI2C);

	/* I2C transaction complete, return status */
	return pxI2C->status;

} /*end ucI2C_SendByte */

/***********************
 * ucI2C_ReceiveByte() *
 **********************/
unsigned portCHAR ucI2C_ReceiveByte (xI2C_struct *pxI2C,
									 unsigned portCHAR addr)
{
	/* Initialize parameters for request */
	pxI2C->opcode	= I2C_ReceiveByte;	/* I2C transaction code */
	pxI2C->addr		= addr;		        /* Address (before left shift) */

	/* Queue I2C transaction request and wait for completion */
	prvI2C_Transaction(pxI2C);

	/* I2C transaction complete, return status */
	return pxI2C->status;

} /*end ucI2C_ReceiveByte */

/*********************
 * ucI2C_WriteByte() *
 ********************/
unsigned portCHAR ucI2C_WriteByte (xI2C_struct *pxI2C,
								   unsigned portCHAR addr,
								   unsigned portCHAR cmd,
								   unsigned portCHAR data)
{

	/* Initialize parameters for request */
	pxI2C->opcode	= I2C_WriteByte;	/* I2C transaction code */
	pxI2C->addr		= addr;		        /* Address (before left shift) */
	pxI2C->comm		= cmd;		        /* Command byte (register offset) */
	pxI2C->data[0]	= data;				/* Write data byte */

	/* Queue I2C transaction request and wait for completion */
	prvI2C_Transaction(pxI2C);

	/* I2C transaction complete, return status */
	return pxI2C->status;

} /*end ucI2C_WriteByte */

/********************
 * ucI2C_ReadByte() *
 *******************/
unsigned portCHAR ucI2C_ReadByte (xI2C_struct *pxI2C,
								  unsigned portCHAR addr,
								  unsigned portCHAR cmd)
{
	/* Initialize parameters for request */
	pxI2C->opcode	= I2C_ReadByte;		/* I2C transaction code */
	pxI2C->addr		= addr;				/* Address (before left shift) */
	pxI2C->comm		= cmd;				/* Command byte (register offset */

	/* Queue I2C transaction request and wait for completion */
	prvI2C_Transaction(pxI2C);

	/* I2C transaction complete, return status */
	return pxI2C->status;

} /*end ucI2C_ReadByte */

/*********************
 * ucI2C_WriteWord() *
 ********************/
unsigned portCHAR ucI2C_WriteWord (xI2C_struct *pxI2C,
								   unsigned portCHAR addr,
								   unsigned portCHAR cmd,
								   unsigned portBASE_TYPE data)
{

	/* Initialize parameters for request */
	pxI2C->opcode	= I2C_WriteWord;	/* I2C transaction code */
	pxI2C->addr		= addr;		        /* Address (before left shift) */
	pxI2C->comm		= cmd;		        /* Command byte (register offset) */
										/* Write data, byte 0 and 1 */
	pxI2C->data[0]	= (unsigned portCHAR) (data & 0x00FF);
	pxI2C->data[1]	= (unsigned portCHAR)((data & 0xFF00) >> 8);

	/* Queue I2C transaction request and wait for completion */
	prvI2C_Transaction(pxI2C);

	/* I2C transaction complete, return status */
	return pxI2C->status;

} /*end ucI2C_WriteWord */

/********************
 * ucI2C_ReadWord() *
 ********************/
unsigned portCHAR ucI2C_ReadWord (xI2C_struct *pxI2C,
								  unsigned portCHAR addr,
								  unsigned portCHAR cmd)
{
	/* Initialize parameters for request */
	pxI2C->opcode	= I2C_ReadWord;			/* I2C transaction code */
	pxI2C->addr	= addr;					/* Address (before left shift) */
	pxI2C->comm	= cmd;					/* Command byte (register offset) */

	/* Queue I2C transaction request and wait for completion */
	prvI2C_Transaction(pxI2C);

	/* I2C transaction complete, return status */
	return pxI2C->status;

} /*end ucI2C_ReadWord */


/************************
 * prvI2C_Transaction() *
 ***********************/
void prvI2C_Transaction (xI2C_struct *pxI2C) {

	unsigned portCHAR q_status;

	/* Set status to error code
	 * - default status is error
	 * - transaction execution will modify the status
	 */
	pxI2C->status	= 0xFF;

	/* Queue the request */
	q_status = (portCHAR) xQueueSend ( pxI2C_RQ, (void *) &pxI2C, (portTickType) 0);

    if (q_status == pdTRUE) {
      /* Request successfully queued
  	   *
  	   * Check/modify the ucI2C_busy flag in a critical section
       * - If NOT busy
       * 	- kick start the I2C controller
       *    - set the ucI2C_busy flag
       *
       * NOTE: If an I2C transaction is already in progress then the
       *       new I2C transaction is simply put on the request queue.
       *       The I2CISR will complete the current I2C transaction and
       *       automatically begin servicing the next I2C request in the
       *       queue.
       */
      portENTER_CRITICAL();

      if (ucI2C_busy == pdFALSE) {
        /* Not busy... */
        WRITE(I2C0CONSET, 0x20);
         ucI2C_busy = pdTRUE;
      }

      portEXIT_CRITICAL();

      /* Wait for the I2C transaction to be completed...
       *
       * HACK HACK HACK - look into MAX limits
       */
      q_status = (portCHAR) xQueueReceive( pxI2C->pxHandle, NULL, (portTickType) 35);

      /* Check the response status */
      if( (q_status != (portCHAR) pdTRUE) || (pxI2C->status != 0) ) {

        /* I2C ERROR during the transaction...
         *
         * The I2CISR attempts to return the I2C controller to an operational
         * state. However, the transaction that encountered the error is NOT
         * recovered.
         *
         * Wait for the I2C bus to timeout (i.e. slave devices).
         *
         * HACK HACK HACK - The timeout value was chosen based on SMBus
         * requirements. This is NOT a guarantee that the bus will return
         * to an operational state. It may also be possible that a shorter
         * timeout would be okay.
         */
        vTaskDelay(35);

      } /* end if( (q_status != (portCHAR) pdTRUE) || (pxI2C->status != 0) ) */

    } /* end if (q_status == pdTRUE) */

    /* Transaction is done
     *
     * Status is in pxI2C structure
     * - if succesfull pxI2C->status == 0
     * - if NOT successful pxI2C->status != 0
     */
    return ;

} /*end prvI2C_Transaction */
